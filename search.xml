<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>盒子模型与Flex/Grid布局</title>
      <link href="/2025/06/08/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E4%B8%8EFlex-Grid%E5%B8%83%E5%B1%80/"/>
      <url>/2025/06/08/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E4%B8%8EFlex-Grid%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>​<strong>盒子模型</strong>由四部分组成：Margin、Border、Padding、Content。</p><p><img src="https://www.runoob.com/images/box-model.gif" alt="img"></p><p>​分为**标准盒模型(content-box)<strong>与</strong>替代盒模型(border-box)**。</p><h3 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h3><ul><li>默认模式，<code>box-sizing: content-box;</code></li><li><code>width/height</code>仅表示<code>Content</code>尺寸</li><li>实际宽度为<code>width(height) + 2*(Padding + Border + Margin)</code></li></ul><h3 id="替代盒模型"><a href="#替代盒模型" class="headerlink" title="替代盒模型"></a>替代盒模型</h3><ul><li>通过<code>box-sizing: border-box</code>来设置</li><li><code>width/height</code>包含<code>Content</code>、<code>Padding</code>、<code>Border</code>的尺寸</li><li>实际宽度为<code>width(height) + 2*Margin</code></li></ul><h3 id="外边距塌陷"><a href="#外边距塌陷" class="headerlink" title="外边距塌陷"></a>外边距塌陷</h3><p>​塌陷指当两个或多个<strong>垂直相邻的块级元素</strong>的外边距相遇时会合并成<strong>单个外边距</strong>的现象。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>两个正外边距时，实际外边距取大的边距，例：20px，50px50px</li><li>一正一负外边距时，实际取两者之和，例：40px，-20px20px</li><li>两个负外边距时，实际外边距取小的边距，例：-20px，-30px-30px</li></ul><h4 id="防止塌陷"><a href="#防止塌陷" class="headerlink" title="防止塌陷"></a>防止塌陷</h4><ul><li><p>使用<strong>BFC</strong>，添加<code>display: flow-root</code></p></li><li><p>添加<code>overflow: hidden; (或 auto, scroll)</code></p></li><li><p><strong>非块级元素</strong>，<code>display: inline-block; width: 100%;</code></p></li><li><p><strong>绝对定位</strong>，<code>position: absolate;</code></p></li><li><p><strong>浮动</strong>，<code>display: float;</code></p></li><li><p>添加隔离层，但会破坏结构</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h2><p>​<strong>一维布局</strong>，通过 <code>display: flex;</code> 或 <code>display: inline-flex;</code> 定义容器。</p><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><ul><li>**<code>flex-direction: row | column | row-reverse | column-reverse</code>**，主轴方向，默认为<code>row</code>水平从左到右，<code>column</code>为竖直从上到下，<code>reverse</code>表示方向相反。</li><li>**<code>flex-wrap: no-wrap | wrap | wrap-resverse</code>**，是否换行，默认不换行，换行，反转方向换行。</li><li><strong><code>justify-content: center | space-between | space-around</code><strong>，</strong>主轴</strong>对齐方式，居中，均分但贴紧边缘，均分。</li><li><strong><code>align-items: center</code><strong>，</strong>交叉轴单行</strong>对齐方式，居中。</li><li><code>align-content: center | space-between | space-around</code>，<strong>交叉轴多行</strong>对齐方式，与<code>justify-content</code>相同。</li></ul><p><strong>注意：</strong>多行时使用<code>justify-content: space-between | space-around</code>可能会导致最后一行与前面的行排版不一致，影响美观。</p><h3 id="子类属性"><a href="#子类属性" class="headerlink" title="子类属性"></a>子类属性</h3><ul><li><code>flex-grow: 0</code>，分配剩余空间的放大比例，默认为0</li><li><code>flex-shrink: 1</code>，空间不足时的缩小比例，默认为1，0表示不收缩</li><li><code>flex-basis: auto</code>，设置子项的初始大小，默认为<code>width</code>或<code>height</code></li><li>**<code>flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;</code>**，缩写</li><li><code>order: 0</code>，项目显示顺序，默认为0，越小越靠前</li><li><code>align-self: </code>auto | flex-start&#x2F;end | center | baseline | stretch，元素在<strong>交叉轴</strong>上的排列方式，默认继承父类的<code>align-items</code>，在交叉轴起点&#x2F;终点对齐，在交叉轴中点对齐，按文本基线对齐，拉伸至填满可用空间(无固定尺寸时生效)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>box8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">flex-direction</span>: column;  // 设置主轴为竖直方向</span></span><br><span class="line"><span class="language-css">        <span class="attribute">flex-wrap</span>: wrap-reverse;  // 反转换行</span></span><br><span class="line"><span class="language-css">        <span class="attribute">justify-content</span>: space-around;  // 设置竖直方向排列方式</span></span><br><span class="line"><span class="language-css">        <span class="attribute">align-content</span>: space-between;  // 设置水平方向多行的排列方式</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box1</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: skyblue;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250609211912300.png" alt="image-20250609211912300" style="zoom: 67%;" /><h2 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h2><p>​<strong>二维布局</strong>，既能控制行，也能控制列，通过<code>display: grid</code>定义容器。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p><code>grid-template-columns / grid-template-rows: 1fr 2fr 1fr</code>，设置列&#x2F;行的数量及宽度，单位可用<code>fr</code>表示浮动宽度，代表grid的剩余空间，示例表示第二列&#x2F;行占据二分之一</p></li><li><p><code>column-gap / row-gap / gap</code>，设置列&#x2F;行&#x2F;行与列间距</p></li><li><p><code>align-items: center | end</code>，设置竖直方向上居中对齐，靠下对齐</p></li><li><p><code>justify-items: center | end | space-between</code>，水平方向居中对齐，靠右对齐，两端对齐</p></li><li><p><code>align-content: center | end / justify-content: center | end | space-between</code>，若行轨道或列轨道的尺寸小于容器大小，还可对轨道进行对齐，竖直&#x2F;水平方向上居中对齐，向下&#x2F;右对齐，水平上两端对齐</p></li><li><p><code>grid-template-areas</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span>Header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">main</span>&gt;</span>Main Content<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aside</span>&gt;</span>Sidebar<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span>Footer<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.layout</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr; // 设置列得到数量及宽度</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-template-rows</span>: <span class="number">1</span>fr <span class="number">2</span>fr <span class="number">1</span>fr; // 设置行的数量及高度</span></span><br><span class="line"><span class="language-css">        <span class="attribute">gap</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-template-areas</span>:  </span></span><br><span class="line"><span class="language-css">        <span class="string">&quot;header header header&quot;</span></span></span><br><span class="line"><span class="language-css">        <span class="string">&quot;aside content content&quot;</span></span></span><br><span class="line"><span class="language-css">        <span class="string">&quot;footer footer footer&quot;</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">header</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-area</span>: header;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">aside</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-area</span>: aside;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">main</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-area</span>: content;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">footer</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-area</span>: footer;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250609223204271.png" alt="image-20250609223204271" style="zoom:67%;" /></li></ul><p><strong>子元素属性</strong></p><ul><li><code>grid-area: areaName | &lt;grid-row-start&gt; &lt;grid-column-start&gt; &lt;grid-row-end&gt; &lt;grid-column-end&gt;</code>，与<code>grid-template-areas</code>结合使用，或直接写精确位置</li><li><code>grid-columns: 1 / 3</code>，<code>grid-rows: 2 / span 2</code>，分别表示，从第一条竖线开始到第三条竖线结束，占两列；从第二条横线开始跨两行</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环与Http缓存</title>
      <link href="/2025/06/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8EHttp%E7%BC%93%E5%AD%98/"/>
      <url>/2025/06/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8EHttp%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li><strong>调用栈：</strong>存放正在执行的函数调用，顺序为先进后出。</li><li><strong>任务队列：</strong>存储异步函数，包括<code>setTimeout</code>、<code>setInterval</code>、I&#x2F;O事件、UI渲染</li><li><strong>微任务队列：</strong>存储微任务，如Promise的<code>.then .catch .finally</code></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>执行一次宏任务，将<strong>同步代码</strong>存入调用栈并执行；</li><li>处理<strong>微任务</strong>，直到队列清空；</li><li><strong>渲染</strong>页面；</li><li>取一个<strong>宏任务</strong>执行，重复上述步骤</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>微任务优先级<strong>高于</strong>宏任务</li><li>每个宏任务执行后会清空微任务队列</li><li>同类型任务按入队顺序执行</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFuncA</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">  <span class="comment">// await 后面的表达式先执行，再将后续 “微任务” 注册到微任务队列</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFuncB</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">  <span class="comment">// 这里没有显式 then，直接 await 会将后续作为微任务</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">asyncFuncNested</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFuncNested</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;nested result&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册多个宏任务与微任务</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;12&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFuncA</span>();</span><br><span class="line"><span class="title function_">asyncFuncB</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;13&#x27;</span>);</span><br><span class="line"><span class="comment">// 错误1 2 5 13 3 4 7 8 6 12 9 10 11</span></span><br><span class="line"><span class="comment">// 正确1 2 5 7 13 3 4 8 6 12 9 10 11</span></span><br></pre></td></tr></table></figure><ul><li>先执行同步任务，输出1，<code>setTimeout</code>为宏任务，进入任务队列，<code>asyncFuncA</code>进入队列输出二，执行await后的表达式并将后续代码注册进微任务队列，await后的表达式.then为微任务并进入微任务队列，<code>asyncFuncA</code>离开队列，<code>asyncFuncB</code>进入队列输出5，await后的<code>asyncFuncNested</code>函数进入队列，输出7并将.then注册进微任务队列，<code>asyncFuncNested,asyncFunB</code>离开队列，输出13，同步代码执行完毕，接下来处理微任务</li><li>先是<code>asyncFuncA</code>里await后的.then，输出3，之后执行await后续代码输出4，然后是<code>asyncFuncB</code>里<code>asyncFuncNested</code>里的微任务，输出8，接着执行<code>asyncFuncB</code>里await后续的代码，输出6，微任务执行完毕，接下来处理下一个宏任务</li><li>执行setTimeout里的代码，输出9，.then进入微任务队列，<code>setTimeout</code>进入任务队列，同步代码执行完毕，执行微任务，输出10，取下一个宏任务，输出12</li><li><strong>注意：</strong>async函数中await后的表达式先执行，再将后续代码注册进微任务队列。</li></ul><h2 id="HTTP缓存机制"><a href="#HTTP缓存机制" class="headerlink" title="HTTP缓存机制"></a>HTTP缓存机制</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><strong>强制缓存：</strong>在有效期内，客户端直接使用本地缓存，不向服务器发送请求</li><li><strong>协商缓存：</strong>强制缓存过期后，客户端携带上次响应提供的校验标识(如<code>ETag</code>或<code>Last-Modified</code>)向服务器询问资源是否变化</li></ul><h3 id="关键响应头"><a href="#关键响应头" class="headerlink" title="关键响应头"></a>关键响应头</h3><ul><li><code>Expires</code>：<strong>强制缓存</strong>，示例：<code>Expires: Wed, 21 Oct 2025 07:28:00 GMT</code>，使用GMT格式的绝对时间，<strong>问题</strong>是客户端与服务端时间不一致会导致缓存不准确。</li><li><code>Cache-Control</code>：<strong>强制缓存</strong>，常见指令：<code>max-age=3600</code>(单位为秒)、<code>no-cache</code>(不使用强制缓存)、<code>no-store</code>(禁止缓存)、<code>private``public</code>(只有浏览器可缓存与浏览器、服务器和代理服务器均可缓存)。</li><li><code>Last-Modified</code>：<strong>协商缓存</strong>，资源的最后修改时间，之后客户端会发送值相同的<code>If-Modified-Since</code>，请求时与最后请求时间对比并确定是否继续使用缓存，<strong>问题</strong>是该响应头以秒级别记录，若资源在一秒内发送变化则无法感知到。</li><li><code>ETag</code>：<strong>协商缓存</strong>，首次请求后响应头返回ETag，值为服务器为文件生成的唯一标识，之后请求客户端会发送值为ETag的<code>If-None-Match</code>，将该值与服务器资源的ETag对比。</li></ul><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ul><li><strong>强制缓存：</strong>客户端拿到资源后记录本地缓存的<code>max-age</code>或<code>Expires</code>，下次请求时，若未过期则直接读取本地缓存，不发送网络请求。</li><li><strong>协商缓存：</strong>强制缓存过期后，客户端带上 <code>If-None-Match</code> 或 <code>If-Modified-Since</code> 向服务器发送请求。若未修改，返回304，继续使用本地缓存，且会更新本次的缓存头；若已修改，返回200和新的资源以及新的缓存头。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js-3</title>
      <link href="/2025/06/07/Node-js-3/"/>
      <url>/2025/06/07/Node-js-3/</url>
      
        <content type="html"><![CDATA[<h2 id="编写接口"><a href="#编写接口" class="headerlink" title="编写接口"></a>编写接口</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./router.js&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>());</span><br><span class="line"><span class="comment">// &#x27;/api&#x27;表示访问该路由时需要加上&#x27;/api&#x27;前缀</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span> , router);</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server started&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"><span class="comment">// 创建get接口</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/get&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">200</span>,  <span class="comment">// 状态码</span></span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;get success&#x27;</span>,  <span class="comment">// 响应信息</span></span><br><span class="line">        <span class="attr">data</span>: req.<span class="property">query</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 创建post接口</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/post&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;post success&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: req.<span class="property">body</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><h3 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h3><p>​cors是express的一个第三方中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(cors);</span><br></pre></td></tr></table></figure><p>​CORS由一系列<strong>HTTP响应头</strong>组成，这些响应头决定浏览器是否阻止前端JS代码跨域获取资源。</p><p><strong>响应头</strong>：</p><ul><li><code>Access-Control-Allow-Origin: url | *</code>  ，”*”表示允许所有域名的请求，只写域名则表示只允许该域名的请求。</li><li><code>Access-Control-Allow-Headers: xx</code> ，默认情况下CORS仅支持9个请求头，若发送了额外的请求头则需要通过该响应头声明，‘xx’表示要声明的请求头。</li><li><code>Access-Control-Allow-Methods: &#39;POST, GET, DELETE, PUT&#39;</code> ，默认情况下CORS仅支持GET、POST、HEAD请求，若要使用其他方式则需要使用该响应头声明，星号表示所有方法。</li></ul><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><ul><li><p><strong>简单请求：</strong>：请求方式为GET、POST、HEAD三者之一，并且请求头无自定义头部字段且在默认支持的9个请求头范围内。</p></li><li><p><strong>预检请求：</strong>：请求方式为其他请求，或请求头包含自定义头部请求，或向服务器发送了<code>application/json</code>格式的数据。</p><p>在浏览器与服务器正式通信前，浏览器会先发送OPTION请求进行预检，以获知服务器是否允许该实际请求。服务器成功响应预检请求后才会发送真正的请求并携带真实数据。</p></li></ul><h3 id="JSONP跨域"><a href="#JSONP跨域" class="headerlink" title="JSONP跨域"></a>JSONP跨域</h3><p>​<strong>JSONP：</strong>浏览器通过<script>标签的src属性请求服务器的数据，同时服务器返回函数的调用。</p><ul><li>JSONP不属于Ajax请求，因为没有使用XMLHttpRequest这个对象。</li><li>仅支持GET方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 从客户端得到函数的名称</span></span><br><span class="line">    <span class="keyword">const</span> fnname = req.<span class="property">query</span>.<span class="property">fnname</span>;</span><br><span class="line">    <span class="comment">// 定义要发送到客户端的数据对象</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;jsonp&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拼接出一个函数的调用</span></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="string">`<span class="subst">$&#123;fnname&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>)`</span>;</span><br><span class="line">    res.<span class="title function_">send</span>(fn);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js-2</title>
      <link href="/2025/06/03/Node-js-2/"/>
      <url>/2025/06/03/Node-js-2/</url>
      
        <content type="html"><![CDATA[<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>​<strong>模块化</strong>指自上而下把系统划分成若干模块的过程。</p><p>​<strong>优点：复用性，可维护性，按需加载。</strong></p><h3 id="模块的分类"><a href="#模块的分类" class="headerlink" title="模块的分类"></a><strong>模块的分类</strong></h3><ul><li><strong>内置模块</strong>，由Node.js官方提供；</li><li><strong>自定义模块</strong>，用户创建的每一个js文件都是自定义模块；</li><li><strong>第三方模块</strong>，使用前需先下载。</li></ul><h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><p>​使用<code>require()</code>方法加载模块，加载模块时会执行模块中的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">// 加载自定义模块需要写出文件路径，&quot;.js&quot;可以省略</span></span><br><span class="line"><span class="keyword">const</span> index = <span class="built_in">require</span>(<span class="string">&#x27;./index.js&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h3><p>​与<strong>函数作用域</strong>类似，在自定义模块中定义的变量、方法等只能在当前模块使用。</p><h3 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h3><p>​每个自定义模块中都有一个module对象，里面存储了和当前模块有关的信息，其中<strong>exports</strong>为暴露的对象，通过exports可以使模块内的成员被外界访问到，导入的结果永远以<strong>module.exports指向的对象</strong>为准。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    a,</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exports对象"><a href="#exports对象" class="headerlink" title="exports对象"></a>exports对象</h3><p>​默认情况下，<code>exports</code>与<code>module.exports</code>指向<strong>同一个对象</strong>，最终结果依旧以<strong>module.exports</strong>为准。</p><p>​但是，<strong>不能直接给exports赋值一个对象</strong>，需要对他的属性赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span>.<span class="property">a</span> = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> = &#123;<span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>&#125;; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>​默认情况下，<code>exports</code>与<code>module.exports</code>指向<strong>同一个对象</strong>，当直接添加属性时，会在原有的内存里添加属性，但如果对<code>module.exports</code>重新赋值一个对象，就会在内存中开辟一个<strong>新的空间</strong>存放赋值的属性与方法，原来对其属性的赋值都无效，也不再与<code>exports</code>指向一个对象。</p><p>​为防止混乱，不要在同一个模块中同时使用<code>exports</code>与<code>module.exports</code>。</p><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><ul><li><p>xxxxxxxxxx const express &#x3D; require(‘express’);const app &#x3D; express();app.get(‘&#x2F;‘, (req, res) &#x3D;&gt; {    &#x2F;&#x2F; 从客户端得到函数的名称    const fnname &#x3D; req.query.fnname;    &#x2F;&#x2F; 定义要发送到客户端的数据对象    const data &#x3D; {        name: ‘jsonp’,        age: 18    }    &#x2F;&#x2F; 拼接出一个函数的调用    const fn &#x3D; <code>$&#123;fnname&#125;($&#123;JSON.stringify(data)&#125;)</code>;    res.send(fn);})js</p></li><li><p><code>package.json</code>用来记录每个包的下载信息，名字、版本号、下载地址等。</p></li><li><p><code>npm init -y</code>快速创建<code>package.json</code>文件。</p></li><li><p><strong>dependencies节点：</strong>用来记录使用安装了哪些包(<strong>核心依赖包</strong>)。</p></li><li><p>使用<code>npm i</code>命令一次性安装所有dependencies中记录的包。</p></li><li><p><strong>devDependencies节点：</strong>记录只在项目开放阶段使用，上线后不用的包(<strong>开发依赖包</strong>)，安装时在命令中加上<code>-D</code>(等价于<code>--save-dev</code>)即可。</p></li><li><p>在执行<code>npm install</code>命令时，若添加了<code>-g</code>参数，则会安装为全局包。</p></li></ul><h3 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h3><ul><li>模块在第一次加载后会被缓存，多次调用require()不会导致模块中的代码执行多次。</li><li><strong>内置模块</strong>加载优先级最高。</li><li>加载自定义模块路径必须为相对路径，否则会被当做内置模块或第三方模块加载。</li></ul><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>​<strong>Express</strong>是基于Node.js平台，快速、开放、极简的<strong>Web开发平台</strong>，与http模块类似。</p><p>​对前端来说，最常见的两种服务器分别是<strong>Web网站服务器</strong>、<strong>API接口服务器</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 把内容响应给客户端</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;666,get成功&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>);</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;666,post成功&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server started&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p><strong>req.query</strong>可以访问客户端通过<strong>查询字符串</strong>的方式发送的参数，即URL中<strong>“?”</strong>后的参数，格式为<code>?username=abc&amp;age=18</code>。</p></li><li><p><strong>req.params</strong>可以访问URL中通过<strong>“:”</strong>匹配到的动态参数。</p><p><strong>客户端</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:8000/paramsname/paramsage&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;queryname&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 请求成功，输出 666,get成功</span></span><br></pre></td></tr></table></figure><p><strong>服务端</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/:name/:age&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;666,get成功&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;paramsName = &quot;</span> + req.<span class="property">params</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;paramsAge = &quot;</span> + req.<span class="property">params</span>.<span class="property">age</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;queryName = &quot;</span> + req.<span class="property">query</span>.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 响应成功，输出 paramsName = paramsname paramsAge = paramsage queryName = query</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h4><p>​**express.static()**可以创建一个静态资源服务器，通过如下代码即可将public文件夹中的图片、css文件、js文件对外开放访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;./public&#x27;</span>));</span><br></pre></td></tr></table></figure><p>​如：<a href="http://localhost:8000/img/bg.jpg%EF%BC%8Chttp://localhost:8000/css/index.css%EF%BC%8Chttp://localhost:8000/js/index.js">http://localhost:8000/img/bg.jpg，http://localhost:8000/css/index.css，http://localhost:8000/js/index.js</a></p><p>​Express在指定的目录中查找文件，并对外提供访问路径，因此存放文件的<strong>目录名不会出现在URL中</strong>。</p><p>​若要托管多个静态资源目录，可以多次调用<code>express.static()</code>函数，访问文件时会按顺序查找。</p><h4 id="挂载路径前缀"><a href="#挂载路径前缀" class="headerlink" title="挂载路径前缀"></a>挂载路径前缀</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/public&#x27;</span>, express.<span class="title function_">static</span>(<span class="string">&#x27;./public&#x27;</span>))</span><br></pre></td></tr></table></figure><p>​在访问静态资源时需带有<code>/public</code>前缀</p><p>​如：<a href="http://localhost:8000/public/img/bg.jpg%EF%BC%8Chttp://localhost:8000/public/css/index.css">http://localhost:8000/public/img/bg.jpg，http://localhost:8000/public/css/index.css</a></p><h2 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express 路由"></a>Express 路由</h2><p>​<strong>路由</strong>指客户端的请求与服务器处理函数之间的映射关系。</p><h3 id="模块化路由"><a href="#模块化路由" class="headerlink" title="模块化路由"></a>模块化路由</h3><p>​为方便对路由的管理，推荐将路由抽离为单独的模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由模块 route1.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;get sucess&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 导出路由模块</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主文件中</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 导入路由模块</span></span><br><span class="line"><span class="keyword">const</span> route1 = <span class="built_in">require</span>(<span class="string">&#x27;./route1.js&#x27;</span>)</span><br><span class="line"><span class="comment">// 注册模块</span></span><br><span class="line">app.<span class="title function_">use</span>(route1);</span><br><span class="line">app.<span class="property">listen</span>...</span><br></pre></td></tr></table></figure><p>为路由模块<strong>添加前缀</strong>，<code>app.use(&#39;/api&#39;, route1)</code>，添加统一的访问前缀 &#x2F;api。</p><h2 id="Express-中间件"><a href="#Express-中间件" class="headerlink" title="Express 中间件"></a>Express 中间件</h2><p>​当一个请求到达Express的服务器后，可以连续调用多个<strong>中间件</strong>对这次请求进行<strong>预处理</strong>，最终结果通过路由响应给客户端。</p><p>​中间件本质上是个函数，格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="title function_">next</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​中间件必须包含<strong>next参数</strong>，且必须在最后调用**<code>next()</code>**。</p><p>​next函数表示把流转关系<strong>转交</strong>给下一个中间件或路由。</p><p>​客户端发起的任何请求，到达服务器后都会触发的中间叫做<strong>全局生效</strong>的中间件，格式为<code>app.use((req, res, next) =&gt; &#123;&#125;)</code>。</p><p>​多个中间件之间共享一份req，res，可以在上游的中间件中添加自定义属性或方法供下游使用。</p><p>​<strong>局部生效</strong>的中间件，格式为<code>app.get(&#39;/&#39;, fn(), (req, res) =&gt; &#123;...&#125;)</code>、<code>app.get(&#39;/&#39;, fn1(), fn2() (req, res) =&gt; &#123;...&#125;)</code>或<code>app.get(&#39;/&#39;, [fn1(), fn2()], (req, res) =&gt; &#123;...&#125;)</code>，其中fn、fn1、fn2为中间件。</p><h3 id="中间件分类"><a href="#中间件分类" class="headerlink" title="中间件分类"></a>中间件分类</h3><ul><li><p><strong>应用级别</strong>的中间件，绑定到<strong>app实例</strong>上的中间件。</p></li><li><p><strong>路由级别</strong>的中间件，绑定到<strong>express.Router()实例</strong>上的中间件。</p></li><li><p><strong>错误级别</strong>的中间件专门用来捕获项目中的错误，形参为<code>(err, req, res)</code>，错误级别的中间件必须注册在<strong>所有路由之后</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err, req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(err.<span class="property">message</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>Express内置</strong>的中间件，包括<code>express.static</code>、<code>express.json</code>、<code>express.urlencoded</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析JSON格式的请求体数据</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>());</span><br><span class="line"><span class="comment">// 解析URL/encoded格式的请求体数据</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span>&#125;));</span><br></pre></td></tr></table></figure><p><code>req.body</code>用来接收客户端发送的请求体数据，若不配置解析表单数据的中间件则默认为<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用axios发送urlencoded格式的数据</span></span><br><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="string">&#x27;name=abc&amp;age=18&#x27;</span>);</span><br><span class="line">params.<span class="title function_">append</span>(<span class="string">&#x27;height&#x27;</span>, <span class="number">180</span>); <span class="comment">// 添加数据</span></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8000&#x27;</span>, params).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>第三方</strong>的中间件</p></li></ul><h2 id="自定义中间体"><a href="#自定义中间体" class="headerlink" title="自定义中间体"></a>自定义中间体</h2><p>​手写一个将JSON数据解析为对象的中间件，类似于express.json。</p><h3 id="首先编写实现代码"><a href="#首先编写实现代码" class="headerlink" title="首先编写实现代码"></a>首先编写实现代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 解析表单数据的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 监听data事件，获取请求体中的数据，只要有数据就会触发</span></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">        str += chunk;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 监听end事件，当数据传输完成时触发</span></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 将JSON字符串解析为对象</span></span><br><span class="line">        req.<span class="property">body</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span><br><span class="line">        <span class="title function_">next</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;post success&#x27;</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(req.<span class="property">body</span>);</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server started&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>next()</code>一定要写在监听<strong>end事件函数中</strong>，因为监听事件是异步任务，如果将next()写在外面会直接执行next()，直到同步任务执行完毕才会执行监听事件，导致数据未被处理。</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsonparser.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">        str += chunk;</span><br><span class="line">    &#125;)</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">        req.<span class="property">body</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">        <span class="title function_">next</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> jsonparser = <span class="built_in">require</span>(<span class="string">&#x27;jsonparser&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(jsonparser);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js-1</title>
      <link href="/2025/06/01/Node-js-1/"/>
      <url>/2025/06/01/Node-js-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>​<strong>Node.js</strong>是一个基于Chrome V8引擎的<strong>JS运行环境</strong>。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>浏览器是js的前端执行环境，node.js是js的后端执行环境。</li><li>Node.js中<strong>无法调用</strong>DOM、BOM与AJAX等<strong>浏览器内置API</strong>。</li></ul><h2 id="fs-文件系统模块"><a href="#fs-文件系统模块" class="headerlink" title="fs 文件系统模块"></a>fs 文件系统模块</h2><p>​引用fs模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="fs-readFile"><a href="#fs-readFile" class="headerlink" title="fs.readFile()"></a>fs.readFile()</h3><p>​使用readFile可以读取指定文件中的内容，格式如下(甚至可以我读我自己)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 读取成功err为null</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取失败时data为undefined</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>参数一：必选，字符串，表示文件路径；</li><li>参数二：可选，表示以什么格式来读取文件，一般默认为utf8；</li><li>参数三：必选，表示回调函数，err为错误信息，data为读取到的内容。</li></ul><h3 id="fs-writeFile"><a href="#fs-writeFile" class="headerlink" title="fs.writeFile()"></a>fs.writeFile()</h3><p>​使用writeFile可以向指定的文件中写入内容，格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&quot;666&quot;</span>,<span class="string">&quot;utf8&quot;</span>,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>参数二表示写入的内容，会覆盖文件的原内容；</li><li>回调函数只有err参数，其余部分与readFile相同；</li><li>若文件不存在，则会新建文件。</li></ul><h3 id="处理路径问题"><a href="#处理路径问题" class="headerlink" title="处理路径问题"></a>处理路径问题</h3><p>​如果操作路径是相对路径。容易出现路径动态拼接错误的问题。</p><p> class person<T>{    name:T;    constructer(name: T){        this.name &#x3D; name;    }}ts</p><p>​可以使用<code>__dirname</code>来表示当前文件所处的目录，可通过字符串的拼接来得到完整路径。</p><h2 id="path-路径模块"><a href="#path-路径模块" class="headerlink" title="path 路径模块"></a>path 路径模块</h2><p>​<strong>path模块</strong>是Node.js官方提供的用来处理路径的模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="path-join"><a href="#path-join" class="headerlink" title="path.join()"></a>path.join()</h3><p>​用来将多个路径片段拼接成一个完整的路径字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">join</span>(__dirname,<span class="string">&quot;/test.txt&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;../&#x27;会抵消一层路经</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">join</span>(<span class="string">&#x27;/a&#x27;</span>,<span class="string">&#x27;/b/c&#x27;</span>,<span class="string">&#x27;../&#x27;</span>,<span class="string">&#x27;./d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>)); <span class="comment">// 输出\a\b\d\e</span></span><br></pre></td></tr></table></figure><h3 id="path-basename"><a href="#path-basename" class="headerlink" title="path.basename()"></a>path.basename()</h3><p>​通过该方法可以获取路径中的<strong>最后一部分</strong>，通常用basename获取路径中的<strong>文件名</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = path.<span class="title function_">basename</span>(path.<span class="title function_">join</span>(__dirname,<span class="string">&quot;name.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 参数二可选，表示文件后缀名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(test)); <span class="comment">// name.txt</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(test,<span class="string">&quot;.txt&quot;</span>)); <span class="comment">// name</span></span><br></pre></td></tr></table></figure><h3 id="path-extname"><a href="#path-extname" class="headerlink" title="path.extname()"></a>path.extname()</h3><p>​用来获取路径中的扩展名，格式为<code>path.extname(path)</code>，返回值为获取的扩展名</p><h2 id="html-模块"><a href="#html-模块" class="headerlink" title="html 模块"></a>html 模块</h2><p>​<strong>http模块</strong>是用来<strong>创建web服务器</strong>的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建server</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line"><span class="comment">// 绑定request事件</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server started&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="req请求对象"><a href="#req请求对象" class="headerlink" title="req请求对象"></a>req请求对象</h4><ul><li><p><strong>req.url</strong>是客户端请求的URL地址</p></li><li><p><strong>req.method</strong>是客户端的method请求类型</p></li></ul><h4 id="res响应对象"><a href="#res响应对象" class="headerlink" title="res响应对象"></a>res响应对象</h4><ul><li><code>res.end(test)</code> 其中test为向客户端发送的内容，并结束本次请求</li></ul><h4 id="res-setHeader"><a href="#res-setHeader" class="headerlink" title="res.setHeader()"></a>res.setHeader()</h4><p>​当调用res.end()方法时，想客户端发送中文内容时会出现<strong>乱码</strong>，为此需要在发送前设置响应头。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>,<span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​参数一为响应头的名字，参数二为该响应头的值。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>​在浏览器访问网址，通过res.url解析出文件路径，再通过fs.readFile()方法读取文件内容，通过res.end()发送给浏览器使html文件呈现在页面上。</p><h3 id="初步代码"><a href="#初步代码" class="headerlink" title="初步代码"></a>初步代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url;</span><br><span class="line">    <span class="comment">// 设置响应头</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>,<span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">    <span class="comment">// 进行判断并合成地址，如果地址为‘/’则替换为html文件地址</span></span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">url</span> === <span class="string">&#x27;/&#x27;</span> || req.<span class="property">url</span> === <span class="string">&quot;index.html&quot;</span>)&#123;</span><br><span class="line">        url = path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;/page/index.html&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        url = path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;/page&quot;</span>, req.<span class="property">url</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(url,<span class="string">&#x27;utf8&#x27;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            res.<span class="title function_">end</span>(<span class="string">&#x27;404 not found&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">end</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server started&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>浏览器根据 HTTP 响应头里的 <code>Content-Type</code> 来决定如何处理收到的资源。如果你不显式把 CSS 文件的 <code>Content-Type</code> 设置成 <code>text/css</code>，浏览器可能会当作 <code>text/plain</code> 或者二进制流处理，最终就不会应用其中的样式，因此页面上不会显示css内容。</li></ul><p>​因此在响应css请求时需要修改响应头，设置为<code>text/css</code>，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>,<span class="string">&#x27;text/css;charset=utf-8&#x27;</span>);</span><br></pre></td></tr></table></figure><p>然而这样的话每种类型的请求都需要重新设置响应头，过于繁琐，因此可以使用<code>mine-types</code>库。</p><h3 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 导入mime-types</span></span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">&#x27;mime-types&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">url</span> === <span class="string">&#x27;/&#x27;</span> || req.<span class="property">url</span> === <span class="string">&quot;test.html&quot;</span>)&#123;</span><br><span class="line">        url = path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;/page/test.html&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        url = path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;/page&quot;</span>, req.<span class="property">url</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(url,<span class="string">&#x27;utf8&#x27;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            res.<span class="title function_">end</span>(<span class="string">&#x27;404 not found&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在响应前设置响应头</span></span><br><span class="line">            <span class="comment">// 使用mime.looker()方法可以得到类似&quot;text/html&quot;、&quot;text/css&quot;、&quot;application/javascript&quot;的返回值</span></span><br><span class="line">            res.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, mime.<span class="title function_">lookup</span>(url) + <span class="string">&#x27;;charset=utf-8&#x27;</span>);</span><br><span class="line">            res.<span class="title function_">end</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server started&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​除此之外还可以使用<code>mime</code>库，但是需要改为ESM模块，即需要：</p><ol><li><p>在<code>package.json</code>中声明<code>&quot;type&quot;: &quot;module&quot;</code>  或  将js文件后缀改为.mjs；</p></li><li><p>将所有<code>require</code>修改为<code>import</code>，但这样就没有了<code>__dirname</code>；</p></li><li><p>在ESM中重建 <code>__filename</code>与<code>__dirname</code>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&#x27;url&#x27;</span>;</span><br><span class="line"><span class="comment">// fileURLToPath(import.meta.url) 会把类似 &#x27;file:///Users/you/project/server.mjs&#x27; 转成 &#x27;/Users/you/project/server.mjs&#x27;</span></span><br><span class="line"><span class="keyword">const</span> __filename = <span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"><span class="comment">// path.dirname(...) 则得出该文件所在的目录</span></span><br><span class="line"><span class="keyword">const</span> __dirname = path.<span class="title function_">dirname</span>(__filename);</span><br></pre></td></tr></table></figure></li><li><p>mime库中与mime-types的lookup方法类似的是getType，其余地方与使用mime-types的方法一致。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript-下-面向对象</title>
      <link href="/2025/05/31/TypeScript-2/"/>
      <url>/2025/05/31/TypeScript-2/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>​除了继承JS的所有特性外，TS还在编译阶段引入了<strong>类(class)<strong>、</strong>接口(interface)<strong>、</strong>泛型(generics)<strong>等语法糖，使我们更容易以</strong>面向对象</strong>的方式编写代码。</p><h3 id="class-类"><a href="#class-类" class="headerlink" title="class(类)"></a>class(类)</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>; <span class="comment">// 默认为public</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span>; <span class="comment">// 可用private关键字修饰属性，此时不可直接调用实例的该属性,需要用get方法来获取</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">sex</span>: <span class="built_in">string</span>; <span class="comment">// readonly表示只读属性，不可被修改</span></span><br><span class="line">    <span class="keyword">static</span> <span class="attr">eyeNum</span>: <span class="built_in">number</span> = <span class="number">2</span>; <span class="comment">// 用static关键字定义类属性(静态属性)或类方法，可直接通过类访问</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="attr">height</span>: <span class="built_in">number</span>; <span class="comment">// protected修饰的属性只能在当前类与子类中使用</span></span><br><span class="line"><span class="comment">// 构造函数，用来初始化实例属性，在创建对象时会调用</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name,age,sex</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 方法，获取age属性值</span></span><br><span class="line">    <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> per = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">18</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="property">name</span>); <span class="comment">// abc</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="property">age</span>); <span class="comment">// error</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="title function_">getAge</span>()); <span class="comment">// 18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">eyeNum</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="property">sex</span>); <span class="comment">// male</span></span><br><span class="line">per.<span class="property">sex</span> = <span class="string">&quot;female&quot;</span>; <span class="comment">// eror</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">sayHi</span>() <span class="comment">// Hi!</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line">    <span class="comment">// 可以直接将属性定义在构造函数中，不需要在定义属性与编写构造函数里的内容</span></span><br><span class="line">    <span class="title function_">constructer</span>(<span class="params"><span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span>,<span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extends-继承"><a href="#extends-继承" class="headerlink" title="extends(继承)"></a>extends(继承)</h3><p>​使用<strong>extends</strong>关键字表示继承，格式为 <code>class 子类 extends 父类&#123;&#125;</code>，子类将会拥有父类所有属性与方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span>; <span class="comment">// 子类只能通过父类的get方法访问private属性</span></span><br><span class="line">    <span class="title function_">constructer</span>(<span class="params"><span class="attr">name</span>: <span class="built_in">string</span>,<span class="attr">age</span>: <span class="built_in">number</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getAge</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">animal</span>&#123;</span><br><span class="line">    <span class="attr">weight</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">constructer</span>(<span class="params">name, age, weight</span>)&#123;</span><br><span class="line">        <span class="comment">// super 表示父类，这里表示执行父类的构造函数</span></span><br><span class="line">        <span class="comment">// 若子类重写了构造函数则必须调用父类的构造函数，即super()</span></span><br><span class="line">        <span class="variable language_">super</span>(name, age);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">weight</span> = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法重写，子类覆盖父类方法</span></span><br><span class="line">    <span class="title function_">satyHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;汪汪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">animal</span>&#123;</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;喵喵&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> <span class="title function_">dog</span>(<span class="string">&quot;dog1&quot;</span>,<span class="number">5</span>,<span class="number">15</span>);</span><br><span class="line"><span class="keyword">const</span> cat1 = <span class="keyword">new</span> <span class="title function_">cat</span>(<span class="string">&quot;cat1&quot;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog1.<span class="title function_">getAge</span>()); <span class="comment">// 5</span></span><br><span class="line">dog1.<span class="title function_">sayHi</span>(); <span class="comment">// 汪汪</span></span><br><span class="line">cat1.<span class="title function_">sayHi</span>(); <span class="comment">// 喵喵</span></span><br></pre></td></tr></table></figure><h3 id="abstract-class-抽象类"><a href="#abstract-class-抽象类" class="headerlink" title="abstract class(抽象类)"></a>abstract class(抽象类)</h3><p>​使用<code>abstract</code>关键字修饰class类，使之成为抽象类，抽象类具有以下特征：</p><ul><li>不能用来创建对象，是专门用来被继承的类；</li><li>可以添加抽象方法，使用<code>abstract</code>修饰方法；</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="attr">name</span>: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象方法没有方法体，子类必须对抽象方法进行重写</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">sayHello</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">animal</span> &#123;</span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;wangwang&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> <span class="title function_">dog</span>(<span class="string">&quot;dog1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ani = <span class="keyword">new</span> <span class="title function_">animal</span>(<span class="string">&quot;ani&quot;</span>); <span class="comment">// error</span></span><br><span class="line">dog1.<span class="title function_">sayHello</span>(); <span class="comment">// wangwang</span></span><br></pre></td></tr></table></figure><h3 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface(接口)"></a>interface(接口)</h3><p>​使用<code>interface</code>关键字声明接口，与普通的类型声明类似</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型声明</span></span><br><span class="line"><span class="keyword">type</span> myType = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> myInterface &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">person1</span>: myType =&#123;<span class="attr">name</span>: <span class="string">&quot;aaa&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">person2</span>: myInterface = &#123;<span class="attr">name</span>:<span class="string">&quot;bbb&quot;</span>&#125;;               </span><br></pre></td></tr></table></figure><p>​但类型声明不能重复被声明，接口可以重复声明，两个接口的并集为最终的接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myType = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> myType = &#123;  <span class="comment">// error</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> myInterface &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> myInterface &#123;</span><br><span class="line"><span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">person1</span>: myType =&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;aaa&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">person2</span>: myInterface = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>;</span><br><span class="line">&#125;;       </span><br></pre></td></tr></table></figure><p>​接口可以在定义类型的时候限制类的结构，只定义对象的结构，其中的属性不能有实际的值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> myInter&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">sayHello</span>(): <span class="built_in">void</span>; <span class="comment">// 接口中所有方法都是抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义类时可以使类实现一个接口，满足接口的要求</span></span><br><span class="line"><span class="comment">// 该类中必须具有接口的所有属性与方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> <span class="keyword">implements</span> myInter&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructer</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性的封装"><a href="#属性的封装" class="headerlink" title="属性的封装"></a>属性的封装</h3><p>​属性可以被任意修改会导致对象中的数据变得非常不安全，使用<strong>封装</strong>可以保证数据的一致性与完整性</p><p>​例如，一个 <code>age</code> 属性可能需要限制在 <code>[0, 150]</code> 之间，如果允许外部直接 <code>person.age = -10</code>，就会导致不合理的状态。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">constructer</span>(<span class="params"><span class="attr">age</span>: <span class="built_in">number</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter用来读取属性，setter用来修改属性，被称为属性的存取器</span></span><br><span class="line">    <span class="comment">// 写法一</span></span><br><span class="line">    <span class="title function_">getAge</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setAge</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">number</span></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value&gt;=<span class="number">0</span> &amp;&amp; value&lt;=<span class="number">150</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">age</span> = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写法二</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">age</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value&gt;=<span class="number">0</span> &amp;&amp; value&lt;=<span class="number">150</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">age</span> = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> per = <span class="keyword">new</span> <span class="title function_">person</span>(<span class="number">18</span>);</span><br><span class="line"><span class="comment">// 写法一对应的写法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="property">getAge</span>); <span class="comment">// 18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="title function_">setAge</span>(<span class="number">20</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="comment">// 写法二对应的写法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="property">age</span>)</span><br><span class="line">per.<span class="property">age</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>​<strong>泛型</strong>可以使一个函数能处理多种不同类型的数据，并保证输入输出类型一致时</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn&lt;T，K&gt;(<span class="attr">a</span>: T,<span class="attr">b</span>: K): T&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">10</span>); <span class="comment">// 不指定泛型，TS可自动对类型进行推断</span></span><br><span class="line">fn&lt;<span class="built_in">string</span>,<span class="built_in">number</span>&gt;(<span class="string">&quot;abc&quot;</span>,<span class="number">123</span>); <span class="comment">// 也可指定泛型</span></span><br></pre></td></tr></table></figure><p>​也可与<strong>接口</strong>结合使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IN&#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> fn&lt;T <span class="keyword">extends</span> <span class="variable constant_">IN</span>&gt;(<span class="attr">a</span>: T):<span class="built_in">number</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​定义<strong>类</strong>时也可使用泛型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="attr">name</span>:T;</span><br><span class="line">    <span class="title function_">constructer</span>(<span class="params"><span class="attr">name</span>: T</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript-上-类型与配置</title>
      <link href="/2025/05/30/TypeScript-1/"/>
      <url>/2025/05/30/TypeScript-1/</url>
      
        <content type="html"><![CDATA[<h2 id="TS是什么"><a href="#TS是什么" class="headerlink" title="TS是什么"></a>TS是什么</h2><ul><li><strong>TypeScript</strong>是一门以JS为基础构建的语言。</li><li>TS是JS的<strong>超集</strong>，所有JS代码均可在TS中运行。</li><li>TS扩展了JS，并添加了类型。</li><li><strong>注意</strong>：TS不能被JS解析器直接执行，需要先编译成JS代码。</li></ul><h2 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>​声明变量时对变量类型进行设置，但即使报错依然会编译成js代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">number</span>;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">&quot;666&quot;</span>; <span class="comment">// error，string类型不能赋值给number类型</span></span><br></pre></td></tr></table></figure><p>​如果同时进行声明与赋值，TS可自动对变量进行类型检测：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">a = <span class="literal">true</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>​也可对函数的参数类型与返回值类型进行声明：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"><span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>,<span class="string">&quot;2&quot;</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h4 id="其他类型："><a href="#其他类型：" class="headerlink" title="其他类型："></a>其他类型：</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">any</span> = <span class="number">1</span>; <span class="comment">// any表示任意类型，相当于关闭了TS的类型检测 </span></span><br><span class="line"><span class="keyword">let</span> b; <span class="comment">// 若不指定类型，自动判断为any</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="built_in">unknown</span> = <span class="number">1</span>; <span class="comment">// unknown表示未知类型的值，实际上是个类型安全的any</span></span><br><span class="line">str = a; <span class="comment">// any类型的值可以赋值给任何类型的值且不报错</span></span><br><span class="line">str = c; <span class="comment">// error</span></span><br><span class="line"><span class="comment">// 类型断言，用来告诉解析器变量的实际类型</span></span><br><span class="line">str = c <span class="keyword">as</span> <span class="built_in">string</span>; </span><br><span class="line">str = &lt;<span class="built_in">string</span>&gt;c; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>): <span class="built_in">void</span>&#123;&#125; <span class="comment">// void表示空值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>): <span class="built_in">never</span>&#123;&#125; <span class="comment">// never表示永远不会返回结果</span></span><br><span class="line"><span class="comment">// &quot;?&quot;表示可选属性，[propName: string]: any表示可添加其他任意类型的属性</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>:&#123;<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>?: <span class="built_in">number</span>, [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>&#125; </span><br><span class="line"><span class="comment">// string[],Array&lt;string&gt;表示字符串数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="built_in">string</span>[]; </span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple 元组"></a>Tuple 元组</h3><p>​<strong>tuple元组</strong>是一种长度固定、数据类型可以不相同的数组类型，可读性与语义性强，类型安全，便于维护，性能优化。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> h : [<span class="built_in">string</span>,<span class="built_in">number</span>];</span><br><span class="line">h = [<span class="string">&quot;abc&quot;</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h3 id="Enum-枚举"><a href="#Enum-枚举" class="headerlink" title="Enum 枚举"></a>Enum 枚举</h3><p>​<strong>enum枚举</strong>是一种定义一组命名变量的方式。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span>&#123;</span><br><span class="line">    male, <span class="comment">// 默认为0</span></span><br><span class="line">    female <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: &#123;<span class="attr">name</span>: <span class="built_in">string</span>,<span class="attr">gender</span>: <span class="title class_">Gender</span>&#125;;</span><br><span class="line">person = &#123;<span class="attr">name</span>:<span class="string">&quot;abc&quot;</span>, <span class="attr">gender</span>: <span class="title class_">Gender</span>.<span class="property">male</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Gender</span>.<span class="property">male</span>) <span class="comment">// 输出0</span></span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>​当类型需要重复使用时，可以为其起个别名，使用别名代替类型名来简化类型的使用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myType = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: myType;</span><br></pre></td></tr></table></figure><h2 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// include 用来指定哪些文件需要被编译, exclude 相反</span></span><br><span class="line">    <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;./src/**/*.ts&quot;</span><span class="punctuation">,</span> <span class="comment">// 表示src目录下的所有目录里的所有ts文件</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;name&quot;</span><span class="punctuation">,</span>  <span class="comment">// 表示排除name目录下的所有文件</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// compilerOptions 表示编译器的选项,</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es6&quot;</span><span class="punctuation">,</span> <span class="comment">// 用来指定编译后的JS代码的目标版本，默认为ES3</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定编译后的JS代码的模块化规范</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定编译后文件的输出目录</span></span><br><span class="line">    <span class="attr">&quot;outfile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/test.js&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定编译后文件的输出文件名并将文件合为一个文件</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;dom&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 指定项目中使用的库，一般不需要手动指定</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否允许编译JS文件，默认为false</span></span><br><span class="line">    <span class="attr">&quot;checkJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否检查JS文件的类型，默认为false</span></span><br><span class="line">        <span class="attr">&quot;removeComments&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 编译后是否移除注释</span></span><br><span class="line">        <span class="attr">&quot;noEmit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 编译后是否生成 .js 文件</span></span><br><span class="line">    <span class="attr">&quot;noEmitOnError&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// 编译出错时是否生成.js 文件</span></span><br><span class="line">        </span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否启用所有严格类型检查选项</span></span><br><span class="line">    <span class="comment">// 是否始终启用严格模式, 默认为false，如果为true，则会在生成文件的顶部添加&quot;use strict&quot;</span></span><br><span class="line">    <span class="comment">// 若文件使用了ES6的模块语法，js文件会自动进入严格模式</span></span><br><span class="line">    <span class="attr">&quot;alwaysStrict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 不允许隐式的any类型</span></span><br><span class="line">    <span class="attr">&quot;noImplicitThis&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 不允许隐式的this类型</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite</title>
      <link href="/2025/05/29/Vite/"/>
      <url>/2025/05/29/Vite/</url>
      
        <content type="html"><![CDATA[<h2 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h2><p>​与<strong>webpack</strong>相同，<strong>Vite</strong>也是前端的构建工具。</p><h2 id="与webpack的不同"><a href="#与webpack的不同" class="headerlink" title="与webpack的不同"></a>与webpack的不同</h2><ul><li>开发时使用<strong>ESM</strong>的方式来运行项目，而不对代码进行打包。</li><li>生产时使用<strong>Rollup</strong>打包方式</li><li>可自动处理常见静态资源，无需像webpack一样配置loader。</li><li>配置简单，开箱即用，无需手动配置。</li></ul><h2 id="Plugins-插件"><a href="#Plugins-插件" class="headerlink" title="Plugins(插件)"></a>Plugins(插件)</h2><p>​Vite也可使用<strong>plugins</strong>，使用方法与webpack类似。</p><p>​配置文件格式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>; <span class="comment">// 可有可无，若不添加则写为 export default&#123;&#125;</span></span><br><span class="line"><span class="comment">// 使用es6的模块化来暴露文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">plugins</span>: [],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​如要使传统浏览器支持可使用<code>@vitejs/plugin-legacy</code>：</p><p>​安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add -D @vitejs/plugin-legacy</span><br></pre></td></tr></table></figure><p>​使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> legacy <span class="keyword">from</span><span class="string">`@vitejs/plugin-legacy`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">legacy</span>(&#123;</span><br><span class="line">      <span class="attr">targets</span>:[<span class="string">&#x27;defaults&#x27;</span>,<span class="string">&quot;ie 11&quot;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="启动速度快"><a href="#启动速度快" class="headerlink" title="启动速度快"></a>启动速度快</h3><ul><li><strong>Vite</strong>：使用<strong>ESM</strong>功能，启动时无需打包。</li><li><strong>Webpack</strong>：启动时需重新构建整个模块依赖图，即使是微小变动也需要重新打包。</li></ul><h3 id="高效能热更新"><a href="#高效能热更新" class="headerlink" title="高效能热更新"></a>高效能热更新</h3><ul><li><strong>Vite</strong>：使用模块级热更新，仅更新被修改的模块。</li><li><strong>Webpack</strong>：每次修改都会触发重打包。</li></ul><h3 id="原生ESM支持"><a href="#原生ESM支持" class="headerlink" title="原生ESM支持"></a>原生ESM支持</h3><ul><li>浏览器原生ESM是未来主流，Vite便基于此设计。</li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li>作为新兴构建工具，插件生态不如webpack丰富。</li><li>对老旧浏览器支持不佳。</li><li>不适合高度定制化构建流程的大型项目。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 构建工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2025/05/28/webpack/"/>
      <url>/2025/05/28/webpack/</url>
      
        <content type="html"><![CDATA[<p>​<strong>webpack</strong>是一个现代JS应用的一个<strong>模块打包器</strong>，作用为将所有资源（JS，css，图片等）打包为多个静态文件。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>​写在webpack.config.js中，格式为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Entry-入口-Output-出口"><a href="#Entry-入口-Output-出口" class="headerlink" title="Entry(入口)  Output(出口)"></a>Entry(入口)  Output(出口)</h3><p>​入口文件与出口文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 入口文件</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">// 入口文件路径</span></span><br><span class="line">  <span class="comment">// 出口文件</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;main.js&#x27;</span>, <span class="comment">// 出口文件名</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// 出口文件路径,必须绝对路径</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>, <span class="comment">// 每次构建是否清除path目录</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Mode-模式"><a href="#Mode-模式" class="headerlink" title="Mode(模式)"></a>Mode(模式)</h3><p>​用于设置编译模式，可选  “production”,”development”,”none”</p><ul><li>production：生产模式，开启代码压缩，如：删除未用到的代码；</li><li>development：开发模式，保留注释，不压缩代码。</li></ul><h3 id="Loaders-加载器"><a href="#Loaders-加载器" class="headerlink" title="Loaders(加载器)"></a>Loaders(加载器)</h3><p>​原生webpack只能打包JS与JSON代码，因此要打包其他资源需要对应的<strong>Loader</strong>（或资源模块Asset Moudules）。</p><p>​如要解析css文件就需要style-loader与css-loader：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/i</span>, <span class="comment">// 指定哪些文件需要被处理，形式为正则表达式</span></span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>], <span class="comment">// 使用哪些loader进行处理,执行顺序为从后往前执行</span></span><br><span class="line">        <span class="comment">// css-loader只负责将css文件转为js，style-loader处理css文件并插入到html中</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Plugins-插件"><a href="#Plugins-插件" class="headerlink" title="Plugins(插件)"></a>Plugins(插件)</h3><p>​不对代码进行处理，但会拓展一些功能，在生命周期中注入或修改行为。</p><p>​如使用<strong>HtmlWebpackPlugin</strong>插件在构建时根据模版生成html并自动注入打包资源：</p><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure></li><li><p>在配置中引入并实例化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="comment">// 引入html-webpack-plugin插件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HTMLPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HTMLPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;test&#x27;</span>, <span class="comment">// 配置生成html文件的标题</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span> <span class="comment">// 配置生成html文件的模板</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;index.html&#x27;</span>, <span class="comment">// 配置生成html文件的名称</span></span><br><span class="line">      <span class="attr">inject</span>: <span class="string">&#x27;body&#x27;</span>, <span class="comment">// 配置html文件插入的位置,放在&lt;/body&gt;前</span></span><br><span class="line">      <span class="attr">minify</span>: <span class="literal">true</span> <span class="comment">// 配置html文件的压缩,打包时压缩html</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Asset-Modules-资源模块"><a href="#Asset-Modules-资源模块" class="headerlink" title="Asset Modules(资源模块)"></a>Asset Modules(资源模块)</h3><p>​<strong>Asset Modules</strong> 是从 <strong>Webpack 5</strong> 开始引入的一种 <strong>新的资源模块类型</strong>，用于代替旧版中通过 <code>file-loader</code>、<code>url-loader</code> 和 <code>raw-loader</code> 等处理静态资源的方式。让我们在不额外安装loader的情况下即可处理一些静态资源。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg,png)$/i</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Devtool"><a href="#Devtool" class="headerlink" title="Devtool*"></a>Devtool*</h3><p>​用来控制如何生成**Source Map(源码映射)**，安装source-map，使源码在浏览器的源代码中可见并可调试。</p><p>​不同的devtool模式，其构建速度、打包体积和映射精度各不相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NodePolyfillPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;node-polyfill-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&quot;inline-source-map&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 构建工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP的三次握手与四次挥手</title>
      <link href="/2025/05/23/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2025/05/23/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、三次握手"><a href="#一、三次握手" class="headerlink" title="一、三次握手"></a>一、三次握手</h2><h3 id="第一次：SYN（同步请求）"><a href="#第一次：SYN（同步请求）" class="headerlink" title="第一次：SYN（同步请求）"></a>第一次：SYN（同步请求）</h3><p>​·  客户端发送带有SYN标志位（SYN&#x3D;1）的报文，并随机生成一个初始序列号。</p><p>​·  告知服务器希望建立连接，并提供初始序列号用于后续数据顺序校验。</p><h3 id="第二次：SYN-ACK（同步确认）"><a href="#第二次：SYN-ACK（同步确认）" class="headerlink" title="第二次：SYN-ACK（同步确认）"></a>第二次：SYN-ACK（同步确认）</h3><p>​·  服务器收到SYN报文后，记录客户端的初始序列号（ISN_C），回复SYN-ACK报文（SYN&#x3D;1,ACK&#x3D;1）。</p><p>​·  SYN-ACK报文包含自己的初始序列号（ISN_S）和确认号（ACK&#x3D;ISN_C+1）.</p><p>​·  表示已收到客户端的SYN，确认客户端的连接请求，同时声明自身的初始序列号。</p><h3 id="第三次：ACK（最终确认）"><a href="#第三次：ACK（最终确认）" class="headerlink" title="第三次：ACK（最终确认）"></a>第三次：ACK（最终确认）</h3><p>​·  客户端收到SYN-ACK报文后发送ACK报文（ACK&#x3D;1），确认号为ISN_S+1。</p><p>​·  客户端确认服务器的响应，双方确认连接可靠。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>​·  交换初始序列号确保数据按需传输；</p><p>​·  验证双方均具备发送与接受信息的能力，确保双向通信。</p><h3 id="为何需要三次？"><a href="#为何需要三次？" class="headerlink" title="为何需要三次？"></a>为何需要三次？</h3><p>​<strong>两次握手：</strong>若在第二次握手后直接分配资源，但客户端未收到SYN-ACK或未响应ACK，服务器资源会被长期占用。</p><p>​<strong>四次握手：</strong>三次已经足够实现功能，第四次交互只会增加延迟。</p><h2 id="二、四次握手"><a href="#二、四次握手" class="headerlink" title="二、四次握手"></a>二、四次握手</h2><h3 id="第一次：FIN"><a href="#第一次：FIN" class="headerlink" title="第一次：FIN"></a>第一次：FIN</h3><p>​·  <strong>客户端</strong>发送FIN报文（FIN&#x3D;1），序列号为seq&#x3D;u，进入FIN_WAIT_1状态，表示不再发送数据，但可接收数据。</p><h3 id="第二次：ACK"><a href="#第二次：ACK" class="headerlink" title="第二次：ACK"></a>第二次：ACK</h3><p>​·  <strong>服务器</strong>收到FIN后，回复ACK报文（ACK&#x3D;1），确认号ack&#x3D;u+1，进入CLOSE_WAIT状态，此时：</p><p>​·  客户端到服务器的连接关闭（单项关闭）；</p><p>​·  服务器可能继续发送未完成的数据。</p><p>​·  客户端收到ACK报文后进入FIN_WAIT_2状态，等待服务器的FIN报文。</p><h3 id="第三次：FIN"><a href="#第三次：FIN" class="headerlink" title="第三次：FIN"></a>第三次：FIN</h3><p>​·  <strong>服务端</strong>处理完数据后发送FIN报文（FIN&#x3D;1,ACK&#x3D;1），序列号seq&#x3D;v，确认号为ack&#x3D;u+1，进入LAST_ACK状态，表示准备关闭连接。</p><h3 id="第四次：ACK"><a href="#第四次：ACK" class="headerlink" title="第四次：ACK"></a>第四次：ACK</h3><p>​·  <strong>客户端</strong>收到FIN后，回复ACK报文（ACK&#x3D;1），确认号ack&#x3D;v+1，进入TIME_WAIT状态，等待一段时间后关闭连接。</p><p>​·  <strong>服务器</strong>收到ACK后立即关闭连接。</p><h3 id="TIME-WAIT状态的作用"><a href="#TIME-WAIT状态的作用" class="headerlink" title="TIME_WAIT状态的作用"></a>TIME_WAIT状态的作用</h3><p>​·  确保最后一个ACK到达被动关闭方。若ACK丢失，被动方会重传FIN，主动方需重新响应。</p><p>​·  防止旧连接的报文干涉新连接。</p><h3 id="为何需要四次挥手"><a href="#为何需要四次挥手" class="headerlink" title="为何需要四次挥手"></a>为何需要四次挥手</h3><p>​TCP每个方向需独立关闭。被动方肯可能在发送ACK后仍有数据发送，因此需将ACK与FIN分开发送，导致四次交互。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从输入URL到出现页面</title>
      <link href="/2025/05/23/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E5%87%BA%E7%8E%B0%E9%A1%B5%E9%9D%A2/"/>
      <url>/2025/05/23/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E5%87%BA%E7%8E%B0%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、解析URL"><a href="#一、解析URL" class="headerlink" title="一、解析URL"></a>一、解析URL</h2><p>​·  浏览器解析输入的URL，检查协议、域名、端口和路径。</p><p>​·  若是非完整URL（如输入baidu.com），浏览器会尝试补全（自动添加https:&#x2F;&#x2F;）。</p><h2 id="二、检查缓存"><a href="#二、检查缓存" class="headerlink" title="二、检查缓存"></a>二、检查缓存</h2><p>​·  浏览器检查HSTS列表，若域名在列表中，自动将HTTP请求升级成HTTPS。</p><p>​·  查看本地缓存是否有该资源的缓存副本，若有效则直接使用。</p><h2 id="三、DNS解析"><a href="#三、DNS解析" class="headerlink" title="三、DNS解析"></a>三、DNS解析</h2><p>​·  每个网址都有对应的ip地址，ip地址有数字组成，不便于记忆，将url地址解析为ip地址的过程就是<strong>DNS解析</strong>。</p><p>​·  DNS就是一个记录着url与其对应的ip地址的数据库。</p><p>​·  将域名转换为ip地址：</p><p>​1.浏览器缓存–&gt;系统缓存（hosts文件）–&gt;路由器缓存–&gt;ISP的DNS服务器。</p><p>​2.若未命中缓存，DNS服务器通过递归查询（如根域名服务器–&gt;顶级域名服务器–&gt;权威域名服务器）。</p><h2 id="四、建立TCP连接"><a href="#四、建立TCP连接" class="headerlink" title="四、建立TCP连接"></a>四、建立TCP连接</h2><p>​·  通过<a href="/2025/05/23/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">三次握手</a>建立连接</p><p>​·  如果是HTTPS，还需进行TLS握手：</p><p>​1.协商加密套件；</p><p>​2.服务器发送证书（由CA机构签发，验证身份）；</p><p>​3.生成会话秘钥（Session Key）,后续通信加密。</p><h2 id="五、发送HTTP请求"><a href="#五、发送HTTP请求" class="headerlink" title="五、发送HTTP请求"></a>五、发送HTTP请求</h2><p>​·  浏览器发送HTTP请求：</p><p>​·  请求行（&lt;请求方式&gt;&lt;请求URL&gt;&lt;HTTP版本&gt;）</p><p>​·  请求头（如User-Agent、Accept、Cookie）</p><p>​·  请求体（如POST方法的表单数据）</p><p>​·  如果是HTTPS，数据会被TLS加密。</p><h2 id="六、服务器处理请求"><a href="#六、服务器处理请求" class="headerlink" title="六、服务器处理请求"></a>六、服务器处理请求</h2><p>​·  服务器接收请求</p><p>​·  生成响应</p><h2 id="七、接受响应并解析"><a href="#七、接受响应并解析" class="headerlink" title="七、接受响应并解析"></a>七、接受响应并解析</h2><p>​·  浏览器接收响应：</p><p>​·  状态码（2xx成功、3xx重定向、4xx客户端错误、5xx服务端错误）</p><p>​·  响应头（Content-Type、Cache-Control、Set-Cookie等）</p><p>​·  响应体（HTML、CSS、JS等）</p><p>​·  解析HTML</p><h2 id="八、加载子资源"><a href="#八、加载子资源" class="headerlink" title="八、加载子资源"></a>八、加载子资源</h2><p>​·  解析过程发现图片、CSS、JS等资源时，重新触发HTTP请求（可能复用TCP连接）</p><p>​·  现代浏览器会通过预加载扫描器提前下载资源</p><h2 id="九、渲染页面"><a href="#九、渲染页面" class="headerlink" title="九、渲染页面"></a>九、渲染页面</h2><p>​· 布局，绘制，合成</p><h2 id="十、连接关闭"><a href="#十、连接关闭" class="headerlink" title="十、连接关闭"></a>十、连接关闭</h2><p>​·  通过<a href="/2025/05/23/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">TCP的四次挥手</a>关闭连接</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2025/05/20/%E9%97%AD%E5%8C%85/"/>
      <url>/2025/05/20/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​当内部函数引用了外部函数的变量，即使外部函数执行完毕，其作用域也不会被销毁，而是被内部函数保留。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>​·   允许函数访问并记住其定义时的词法作用域。</p><p>​·   在定义时确定作用域，而非执行时，内部函数可以访问外部函数的变量、参数和函数。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(++count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">outer</span>();  <span class="comment">// 输出1</span></span><br><span class="line"><span class="title function_">outer</span>();  <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>​1.数据封装私有化：隐藏变量，只通过特定变量接口暴露操作；</p><p>​2.保留函数状态：可用于 计数器、缓存、防抖&#x2F;节流函数；</p><p>​3.模块化开发：结合立即执行函数可以隔离作用域，避免全局污染。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>​有内存泄漏风险：及时解除闭包引用，obj&#x3D;null。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/05/18/hello-world/"/>
      <url>/2025/05/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>友情链接</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<ul class=list>    <li>        <a href="https://qinchuid.github.io/">            <span class=img><img  src="/img/xiaodi.jpg"></span>            <div class="name">琴吹滴</div>            <div class="jieshao">不熟</div>        </a>    </li>    <li>        <a href="https://benksih.github.io">            <span class=img><img  src="/img/benksih.jpg"></span>            <div class="name">Benksih</div>            <div class="jieshao">不认识</div>        </a>    </li>    </ul><style>    .list{        list-style: none;    }    .list li{        height: 210px;        width: 140px;        float: left;    }    .list li a:hover{        transform: scale(1.1);        transition: all .3s;        box-shadow: 0 0 15px #00c4b6;        border-radius: 10px;        text-decoration: none;    }    .list li a{        display: flex;        flex-direction: column;        justify-content: center;        align-items: center;                flex-wrap: wrap;    }    .list img{        width: 100px;        height: 100px;    }    .list li .img{        width: 100px;        height: 100px;        border-radius: 50%;        overflow: hidden;    }    .list li .name{        font-size: 18px;        font-weight: 700;        color: rgb(0, 0, 0);    }    .list li .jieshao{        font-size: 14px;        color: rgba(0, 0, 0,.5);    }</style>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>列表</title>
      <link href="/list/index.html"/>
      <url>/list/index.html</url>
      
        <content type="html"><![CDATA[<p>666</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
